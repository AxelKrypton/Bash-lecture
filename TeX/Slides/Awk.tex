%-------------------------------%
%  Author: Alessandro Sciarra   %
%    Date: 12 Sep 2019          %
%-------------------------------%

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{Awk: Another marvellous utility}
    \begin{varblock}{quote}[\textwidth]{A bit of history}[Awk manual]
        \textnormal{
            \fbox{\parbox{\dimexpr\columnwidth-1cm}{\centering\footnotesize
                \begin{tabular}{l@{\hspace{15mm}}l}
                    1 part \texttt{egrep} & 1 part \texttt{snobol}\\
                    2 parts \texttt{ed}   & 3 parts \texttt{C} \\
                \end{tabular}\\
                Blend all parts well using \texttt{lex} and \texttt{yacc}.
                Document minimally and release.\\
                After eight years, add another part \texttt{egrep} and two more parts \texttt{C}.
                Document very well and release.
            }}\\[1.5ex]
            The name \bash|awk| comes from the initials of its designers: Alfred V. Aho, Peter J. Wein-berger, and Brian W. Kernighan.
            The original version of \bash|awk| was written in \alert{1977} at AT\&T Bell Laboratories.
        }\\[-1ex] ~
    \end{varblock}
    \begin{varblock*}{}[0.85\textwidth]{Some references}
        Awk can be considered to all intents and purposes as a programming language!\\
        $\quad$\URL[PB]{https://www.gnu.org/software/gawk/manual/}{The official GNU manual} {\tiny\{~The PDF is \alert{570} pages long\ldots~\}}\\
        $\quad$\URL[PS]{http://www.grymoire.com/Unix/Awk.html\#uh-0}{A base tutorial}
    \end{varblock*}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{The PDF manual is 570 pages long!! What should I learn here?}
    \vspace{-4mm}
    \begin{itemize}
        \item We will focus on the abstract idea of \textbf{how} \bash|awk| processes a file
        \item Some of the simplest aspects will be introduced
        \item Awk is so powerful that just knowing something is worth it; mastering it is probably not needed for a physicist, though
    \end{itemize}
    \begin{uncoverenv}<2->
        \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm]
            # Invocation
            awk |+[OPTIONS...] 'program' [INPUTFILE...]+|

            # General structure to be put in [SCRIPT]
            |+  BEGIN { action }+|     # Optional block
            |+pattern { action }+|     #
            |+...               +|     # { action } can be omitted
            |+pattern { action }+|     #
            |+    END { action }+|     # Optional block
        \end{lstlisting}
    \end{uncoverenv}
    \begin{itemize}[<3>]
        \item \texttt{BEGIN} and \texttt{END} are special pattern, indeed
        \item The default action is print the record (i.e. the line)
        \item If only the \texttt{BEGIN} block is given, no input is read
        \item If no input is given but one is needed, \bash|awk| reads from standard input
    \end{itemize}
    \FrameRemark{There are other special pattern, which are less common and which can be found in the manual.}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{The \bash|awk| spirit: A data driven processing}
    \vspace{-3mm}
    \begin{enumerate}
        \item Before starting processing the input file(s), the \texttt{BEGIN} block, if present, is processed.
              There is no default action for this block.
        \item Input is read until the \textbf{R}ecord \textbf{S}eparator is found (generally an end-of-line).
        \item Some default record processing is done, e.g. splitting it in fields, and builtin variables are updated.
        \item Processing of the part of input is done, executing the blocks in the given orders.\\
              An action in a block might jump to reading from the input, skipping the following blocks.
        \item Input is read again, i.e. go to \MakeEnumerateBox{2}.
        \item After having processed the last bunch of input (i.e. that terminated by the end-of-file of the last file), the \texttt{END} block, if present, is processed.\\
              There is no default action for this block.
    \end{enumerate}
    \begin{varblock}{}[0.75\textwidth]{Some terminology}
        \begin{description}[XX\textbf{Record:}]
            \item[\textbf{Record:}] The bunch of input read at each iteration
            \item[\textbf{Field:}] Each piece in which each record is automatically split
        \end{description}
    \end{varblock}
    \FrameRemark{There are exceptions to the flow above (e.g. the \texttt{exit} keyword). \alert{Use this slide as approximated overview.}}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{8 powerful \bash|awk| builtin variables and the field placeholders}
    \begin{description}
        \item[\textbf{FS}]
        \item[\textbf{OFS}]
        \item[\textbf{RS}]
        \item[\textbf{ORS}]
        \item[\textbf{NR}]
        \item[\textbf{NF}]
        \item[\textbf{FILENAME}]
        \item[\textbf{FNR}]
    \end{description}
    \begin{description}
        \item[\$n] 
        \item[\$(n)]
    \end{description}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Variables in \bash|awk| and passing Bash variables to \bash|awk|}
    \vspace{-3mm}
    \begin{itemize}
        \item Strings that do not refer to keyword or to builtin variables/functions in \bash|awk| programs are treated as variables
        \item \alert{Numeric variables in \bash|awk| are implicitly initialised to 0, use them without worries!}
        \item The \bash|awk| command-line option \PP{\texttt{-v var=val} sets the \bash|awk| variable} \texttt{var} to the value \texttt{val} \PP{before execution of the program begins}
        \item The \texttt{-v} option can only set one variable, but it can be used more than once, setting another variable each time
              \alert{Avoid setting \bash|awk| builtin variables!}
    \end{itemize}
    \begin{lstlisting}[style=MyBash, xleftmargin=2mm, xrightmargin=2mm]
        $ awk 'BEGIN{print uninitialisedVariable}'
        |++|
        $ awk 'BEGIN{var++; print var}'
        |+1+|
        $ aVar='Hello'
        $ awk -v hi="${aVar}" -v sum=1 'BEGIN{sum++; print hi " " sum}'
        |+Hello 2+|
        $ awk -v index=1 'BEGIN{print index}'
        |+awk: fatal: cannot use gawk builtin `index' as variable name+|
    \end{lstlisting}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{A (very limited) taste of \bash|awk| by examples}
    
\end{frame}

