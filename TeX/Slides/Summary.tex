%-------------------------------%
%  Author: Alessandro Sciarra   %
%    Date: 20 Oct 2020          %
%-------------------------------%

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{Before we say each other goodbye}
    \begin{itemize}
        \item I would like to make an interactive review of the material.
        \item Do not hesitate to ask!
        \item It is an opportunity to refresh your mind and clarify your doubts.
    \end{itemize}
    \vspace{5mm}
    \begin{uncoverenv}<2>
        \centerline{\includegraphics[width=0.7\textwidth]{QuizTime}}
    \end{uncoverenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Day 1}
    \vspace{-3mm}
    \begin{onlyenv}<1-4>
        \begin{lstlisting}[style=myBash, numbers=none]
            if [[ -f 'File with spaces.dat' ]]; then
                rm File with spaces.dat
            fi
        \end{lstlisting}
        \begin{quiz}[1]{Is the above snippet correct? Why?}
            \wrongChoice{Yes, if the file exists, it gets removed.}
            \correctChoice{No, One file should be removed, but three are potentially deleted!}
            \wrongChoice{Yes, if the file does not exist, the code works fine.}
        \end{quiz}
        \begin{uncoverenv}<3-4>
            \begin{lstlisting}[style=myBash, numbers=none]
                function echo() {
                    echo "A clever echo implementation"
                    # ...
                }
            \end{lstlisting}
            \begin{quiz}[3]{Sourcing the snippet above in a terminal, what will it happen?}
                \wrongChoice{An error will occur, no function can take the name of a builtin.}
                \wrongChoice{Nothing, the echo builtin will continue to be used by the shell.}
                \correctChoice{Functions have higher priority than builtins. The \bash|echo| builtin will be shadowed.}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
    \begin{onlyenv}<5-8>
        \begin{lstlisting}[style=myBash, numbers=none]
            $ IFS='_'; echo ${IFS}; unset -v 'IFS'
        \end{lstlisting}
        \begin{quiz}[5]{What does the above command print?}
            \wrongChoice{Nothing, the internal field separator cannot be printed.}
            \correctChoice{Nothing, the shell performs world splitting after the variable is expanded.}
            \wrongChoice{Since the \bash|IFS| is reset to a visible character, an underscore is here printed.}
        \end{quiz}
        \begin{uncoverenv}<7-8>
            \begin{lstlisting}[style=myBash, numbers=none]
                function join() {
                    IFS='_'; echo $*
                }
            \end{lstlisting}
            \begin{quiz}[7]{What does the above function does? Is it good code?}
                \wrongChoice{The function prints a underscore-separated list of its arguments. To change the \bash|IFS| globally should be avoided, though.}
                \wrongChoice{This is a clever way to concatenate strings with a symbol as separator. Good code.}
                \correctChoice{The function prints its arguments and on top it changes the \bash|IFS| globally. Wrong code!}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
    \begin{onlyenv}<9-12>
        \begin{lstlisting}[style=myBash, numbers=none]
            $ echo {1..$(date +'%d')|+}+|  # %d is the day of the month
        \end{lstlisting}
        \begin{quiz}[9]{What does the above command print?}
            \wrongChoice{It prints the numbers from 1 to the present day of the month.}
            \correctChoice{\texttt{\{1..20\}} gets printed since brace expansion happens before command substitution.}
            \wrongChoice{An error is printed, command substitution cannot be used in brace expansion.}
        \end{quiz}
        \begin{uncoverenv}<11-12>
            \begin{lstlisting}[style=myBash, numbers=none]
                echo 3.2*4 | bc -l
            \end{lstlisting}
            \begin{quiz}[11]{Does the above good code do the required multiplication?}
                \wrongChoice{Yes. Bash does not support floating point operations and \bash|bc| can be used in this case.}
                \wrongChoice{Yes, the code above always works. However, a here-string construct would be better to avoid to use \bash|echo| and the pipeline.}
                \correctChoice{This code is wrong! \uncover<12>{Shell automatically does filename extension. Often it might work, but only if the filename extension fails and \texttt{nullglob} is not set!}}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Day 2}
    \vspace{-3mm}
    \begin{onlyenv}<1-4>
            \begin{lstlisting}[style=myBash, numbers=none, xleftmargin=3mm, xrightmargin=3mm]
                if [ ! $1 =~ ^([0-9]+-)?[0-9]{1,2}:[0-9]{2}:[0-9]{2}$ ]; then
                    echo "Error: Walltime specified in a wrong format!"
                fi
            \end{lstlisting}
            \begin{quiz}[1]{Is there anything wrong in the above snippet of code?}
                \wrongChoice{No, a regular expression test is done to check the format of \bash|$1|.}
                \correctChoice{The \bash|[| command does not support the \bash|=~| comparison. With \bash|[[| keyword the code works.}
                \wrongChoice{Even with \bash|[[|, the code is wrong, because the regex pattern must be quoted!}
            \end{quiz}
        \begin{uncoverenv}<3-4>
            \begin{lstlisting}[style=myBash, numbers=none]
                for file in ${array[@]}; do
                    # do something with file
                done
            \end{lstlisting}
            \begin{quiz}[3]{Does the above for loop always work?}
                \wrongChoice{Yes, using arrays is the best way to iterate over files.}
                \wrongChoice{the snippet above works, but it is better to use globbing directly in the for construct.}
                \correctChoice{Although the code above might works, it is in general wrong!\\
                               \uncover<4->{Use \tc{strings-color}{\texttt{"\$\{array[@]\}"}} to avoid word splitting!}}
            \end{quiz}
            \end{uncoverenv}
    \end{onlyenv}
    \begin{onlyenv}<5-8>
        \begin{lstlisting}[style=myBash, numbers=none]
            for((index = 0; index < |+${#array[@]}+|; index ++)); do
                # Do something with ${array[index]}
            done
        \end{lstlisting}
        \begin{quiz}[5]{What would you say about the for loop above?}
            \wrongChoice{Nothing, it uses the C-like for loop to iterate over an array.}
            \correctChoice{It is advisable to iterate over the indices via \tc{strings-color}{\texttt{"\$\{!array[@]\}"}}. If the array is sparse, the code above will fail.}
            \wrongChoice{The code will fail. Spaces in assignments and in the index increment are wrong in bash.}
        \end{quiz}
        \begin{uncoverenv}<7-8>
            \begin{lstlisting}[style=myBash, numbers=none]
                $ index=1; array=(one two three)
                $ unset -v 'array[${index}]'; printf '%s\n' "${array[@]}"
            \end{lstlisting}
            \begin{quiz}[7]{Is the above usage of \bash|unset| correct?}
                \correctChoice{Yes, it is. The \bash|index| variable is accessed in arithmetic context when the array element is being unset.}
                \wrongChoice{No, it isn't. Single quotes prevent parameter expansion and \bash|unset| will then fail.}
                \wrongChoice{No, it isn't. No quotes should be used around \texttt{array[\$\{index\}]}.}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
    \begin{onlyenv}<9-12>
        \begin{quiz}[9]{Which of the following statements ist correct?}
            \wrongChoice{A bash script can change the shell environment when executed.}
            \wrongChoice{Using \bash|export| builtin it is possible to change environment variables for the parent process.}
            \correctChoice{Sourcing a script is a way to affect the environment where it is sourced.}
            \correctChoice{It is possible to specifying a temporary environment change which only takes effect for the duration of that command.}
        \end{quiz}
        \begin{uncoverenv}<11-12>
            \begin{lstlisting}[style=myBash, numbers=none]
                for file in *; do
                    # Do something with files
                done
            \end{lstlisting}
            \begin{quiz}[11]{Do you have any comment about the for-loop above?}
                \wrongChoice{Yes, the code above does not work. Filenames should be stored in an array first.}
                \wrongChoice{No. Using globbing is the write way to iterate over files in the present folder.}
                \correctChoice{The code might do something unexpected! \uncover<12>{Be sure to handle the no-file-scenario correctly (or set \texttt{nullglob})!}}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Day 3}
    \vspace{-3mm}
    \begin{onlyenv}<1-4>
            \begin{lstlisting}[style=myBash, numbers=none, xleftmargin=3mm, xrightmargin=3mm]
                # Keep only first three lines of a file
                $ head -n3 filename > filename
            \end{lstlisting}
            \begin{quiz}[1]{Does the code above work?}
                \wrongChoice{Yes, provided that the file \bash|filename| exists.}
                \wrongChoice{No, the \bash|head| command must run in a subshell to access the file content before it gets overwritten.}
                \correctChoice{No, because redirection is the first thing that bash does. The content of the file is lost before running \bash|head|!}
            \end{quiz}
        \begin{uncoverenv}<3-4>
            \begin{lstlisting}[style=myBash, numbers=none]
                $ wc -c <<< Hello
            \end{lstlisting}
            \begin{quiz}[3]{Which number is printed by the above command?}
                \correctChoice{6. In the here-string construct Bash appends an endline to the string.}
                \wrongChoice{5. Although an endline is appended to the string before passing it on to \bash|wc| standard input, this is not counted.}
                \wrongChoice{The command above gives an error since the string is not quoted.}
            \end{quiz}
            \end{uncoverenv}
    \end{onlyenv}
    \begin{onlyenv}<5-8>
        \begin{lstlisting}[style=myBash, numbers=none]
            #
        \end{lstlisting}
        \begin{quiz}[5]{What would you say about the for loop above?}
            \wrongChoice{}
            \correctChoice{}
            \wrongChoice{}
        \end{quiz}
        \begin{uncoverenv}<7-8>
            \begin{lstlisting}[style=myBash, numbers=none]
                #
            \end{lstlisting}
            \begin{quiz}[7]{Is the above usage of \bash|unset| correct?}
                \correctChoice{}
                \wrongChoice{}
                \wrongChoice{}
            \end{quiz}
        \end{uncoverenv}
    \end{onlyenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
