%-------------------------------%
%  Author: Alessandro Sciarra   %
%    Date: 25 Sep 2020          %
%-------------------------------%

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\againframe<1,3>{IOflow}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}<1-2,4>[fragile, label=FDfigure]{File descriptors: a graphical overview} % https://tex.stackexchange.com/a/119310
    \vspace{-5mm}
    \begin{varblock}{example}[0.66\textwidth]{By default}
        Every new process starts with \textbf{three} open file descriptors.
    \end{varblock}
    \vfill
    \begin{center}
        \begin{tikzpicture}
            \tikzset{fd/.style={minimum size=1cm, draw=#1, very thick, font=\ttfamily}, every path/.style={thick}}
            \node[minimum size=16mm, text width=14mm, draw=PS, very thick, align=center] (script) {Script Command};
            \node[fill=PB, text=bg, thick, circle, inner sep=1pt, font=\footnotesize] at (script.north) {1};
            \node[fd=fg,  left = 20mm of script] (fd0) {FD0};
            \node[fd=PP, right = 22mm of script, anchor=south west, yshift=+1pt] (fd1) {FD1};
            \node[fd=PT, right = 22mm of script, anchor=north west, yshift=-1pt] (fd2) {FD2};
            \draw[to] (fd0.east) -- (script.180) node[midway, fill=bg, font=\scriptsize] {Std Input};
            \draw[to] (script.0) -- (fd1.180) node[fill=bg, midway, inner ysep=0mm, font=\scriptsize, text=PP, sloped] {Std Output};
            \draw[to] (script.0) -- (fd2.180) node[fill=bg, midway, inner ysep=0mm, font=\scriptsize, text=PT, sloped] {Std Error};
            \begin{scope}[scope on=<2->]
                \node[minimum size=16mm, text width=14mm, draw=PS, very thick, align=center, below = 15mm of script] (scriptNew) {Script Command};
                \node[fill=PB, text=bg, thick, circle, inner sep=1pt, font=\footnotesize] at (scriptNew.north) {2};
                \node[fd=fg,  left = 20mm of scriptNew] (fd0new) {FD0};
                \node[fd=PP, right = 22mm of scriptNew, anchor=south west, yshift=+1pt] (fd1new) {FD1};
                \node[fd=PT, right = 22mm of scriptNew, anchor=north west, yshift=-1pt] (fd2new) {FD2};
                \draw[to] (fd0new.east) -- (scriptNew.180) node[midway, fill=bg, font=\scriptsize] {Std Input};
                \draw[to] (scriptNew.0) -- (fd1new.180) node[fill=bg, midway, inner ysep=0mm, font=\scriptsize, text=PP, sloped] {Std Output};
                \draw[to] (scriptNew.0) -- (fd2new.180) node[fill=bg, midway, inner ysep=0mm, font=\scriptsize, text=PT, sloped] {Std Error};
            \end{scope}
            \begin{scope}[scope on=<4>]
                \draw[to] (fd1.0) -- ++(5mm,0) |- ($(script)!0.5!(scriptNew)$) -| ($(fd0new.180)-(5mm,0)$) -- (fd0new.180);
                \node[text=PB, fill=bg] at ($(script)!0.5!(scriptNew)$) {Pipeline};
            \end{scope}
            \begin{scope}[scope on=<5>]
                \draw[to, PQ] (fd1.0) -- ++(5mm,0) |- ($(script)!0.5!(scriptNew)$) -| ($(fd0new.180)-(5mm,0)$) -- (fd0new.180);
                \node[text=PT, fill=bg, draw=PQ, rounded corners=1mm] at ($(script)!0.5!(scriptNew)$) {Pipeline};
            \end{scope}
        \end{tikzpicture}
    \end{center}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{File descriptors}
    \vspace{-3mm}
    In an interactive shell, or in a script running in a terminal,
    \begin{enumerate}\addtocounter{enumi}{-1}
        \item the \textbf{Standard Input} is how Bash sees the characters you type on your keyboard;
        \item the \PP{\textbf{Standard Output}} is where the program sends most of its normal information;
        \item the \alert{\textbf{Standard Error}} is where the program sends its error messages.
    \end{enumerate}
    \begin{varblock}{example}[0.9\textwidth]{Good practice}
        Remember that when you create scripts, you should send your custom error messages to the standard error FD.
        This is a convention and it is very convenient when applications follow the convention. \textbf{As such, so should you!}
    \end{varblock}
    \medskip
    In the following we will learn how to
    \begin{itemize}
        \item redirect standard \{input,error,output\} of \{single,multiple\} commands;
        \item open and close new file descriptors;
        \item use and not abuse the pipeline.
    \end{itemize}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Input/Output Redirection: Some examples}
    \vspace{-8mm}
    \begin{overlayarea}{\textwidth}{0.7\textheight}
        \begin{varblock}{quote}[\textwidth]{Redirection}
            \normalsize\textnormal{The practice of changing a FD to read its input from, or send its output to, a different location}
        \end{varblock}
        \begin{onlyenv}<1>
            \begin{lstlisting}[style=MyBash, aboveskip=2mm]
                # Standard OUTPUT redirection
                $ ls; echo 'Pi*10^7s approximates at 0.38% a year'
                |+Pi*10^7s approximates at 0.38% a year+|
                $ echo 'Pi*10^7s approximates at 0.38% a year' > Quote.txt
                $ ls; cat Quote.txt
                |+Quote.txt+|
                |+Pi*10^7s approximates at 0.38% a year+|
                $ echo '82000 is a super cool number!' > Quote.txt
                $ cat Quote.txt
                |+82000 is a super cool number!+| # We lost the file content!
                $ echo 'Pi*10^7s approximates at 0.38% a year' >  Quote.txt
                $ echo '82000 is a super cool number!'         >> Quote.txt
                $ cat Quote.txt
                |+Pi*10^7s approximates at 0.38% a year+|
                |+82000 is a super cool number!+|
                $ wc -l Quote.txt
                |+2 Quote.txt+|
                $ man wc # What happens if you do not provide a file to wc?
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<2>
            \begin{lstlisting}[style=MyBash, aboveskip=2mm, firstnumber=19]
                # Standard INPUT redirection
                $ wc -l < Quote.txt
                |+2+|
                # Standard ERROR redirection
                $ rm Quote.ttx
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                $ rm Quote.ttx > Error.log
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                $ ls; wc -l Error.log
                |+Error.log   Quote.txt+|
                |+0 Error.log+|
                $ rm Quote.ttx 2> Error.log
                $ wc -l Error.log
                |+1 Error.log+|
                $ rm Quote.ttx 2>> Error.log
                $ cat Error.log
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<3>
            \begin{lstlisting}[style=MyBash, aboveskip=2mm, firstnumber=37]
                # Use of the pipeline
                $ cat Error.log Quote.txt | sort
                |+82000 is a super cool number!+|
                |+Pi*10^7s approximates at 0.38% a year+|
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                $ cat Error.log Quote.txt | sort | uniq
                |+82000 is a super cool number!+|
                |+Pi*10^7s approximates at 0.38% a year+|
                |+rm: cannot remove 'Quote.ttx': No such file or directory+|
                # BAD CODE (Abuse of the pipeline)
                $ cat Quote.txt | grep 'cool'
                |+82000 is a super cool number!+|
                # GOOD CODE: grep 'cool' Quote.txt
                # BAD Bash CODE (Abuse of the pipeline)
                $ echo "2*5.3" | bc -l
                |+10.6+|
                # You should use the Herestrings syntax we'll discuss later
            \end{lstlisting}
        \end{onlyenv}
    \end{overlayarea}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{Input/Output Redirection: The theory}
    \vspace{-3mm}
    \begin{itemize}
        \item I/O redirection is done \alert{\textbf{before}} the command is executed
        \item Redirections are processed in the order they appear, \textbf{from left to right}
        \item In the following slides \PB{\texttt{[n]}} refers to an optional integer, whose default is
              \begin{itemize}
                  \item[0] if the redirection operator is \PB{\texttt{<}} or \PB{\texttt{<>}}
                  \item[1] if the redirection operator is \PB{\texttt{>}} or \PB{\texttt{>>}}
              \end{itemize}
        \item The \texttt{word} following the redirection operator in the following slides is subjected to$^\star$
              \begin{itemize}
                  \item brace expansion
                  \item tilde expansion
                  \item parameter expansion
                  \item command substitution
                  \item arithmetic expansion
                  \item word splitting
                  \item filename expansion
                  \item quote removal
              \end{itemize}
              \alert{If it expands to more than one word, Bash reports an error}
    \end{itemize}
    \FrameRemark{$^\star$ For \PB{heredocs} and \PB{herestrings} a different rule applies: Refer to the Bash manual for more details.}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}{I/O Redirection: The syntax}
    \vspace{-3mm}
    \setbeamerfont{description item}{series=\bfseries}
    \setbeamercolor{description item}{fg=PP}
    \begin{description}[Redirecting Output:]
        \item[Redirecting Input:] \PB{\small\texttt{[n]<word}}\\
            {\small
                The file resulting from the expansion of \texttt{word} is opened for \PS{reading} on FD \texttt{n}
            }
        \item[Redirecting Output:] \PB{\small\texttt{[n]>word}}\\
            {\small
                The file resulting from the expansion of \texttt{word} is opened for \PS{writing} on FD \texttt{n}\\[-0.5em]
                \Remark[0pt]{If the file does not exist it is created; if it does exist it is \textbf{truncated to zero size}}
            }
        \item[Appending Output:] \PB{\small\texttt{[n]>>word}}\\
            {\small
                The file resulting from the expansion of \texttt{word} is opened for \PS{appending} on FD \texttt{n}
            }
        \item[Duplicating FDs:] \PB{\small\texttt{[n]<\&number}} \,and\, \PB{\small\texttt{[n]>\&number}}\\
            {\small
                The file descriptor denoted by \texttt{n} is made to be a copy of file descriptor \texttt{number}\\
                If \texttt{number} does not specify an open file descriptor, a redirection error occurs
            }
        \item[Closing FDs:] \PB{\small\texttt{[n]<\&-}} \,and\, \PB{\small\texttt{[n]>\&-}}\\
            {\small
                The file descriptor denoted by \texttt{n} is closed
            }
        \item[Moving FDs:] \PB{\small\texttt{[n]<\&number-}} \,and\, \PB{\small\texttt{[n]>\&number-}}\\
            {\small
                The FD \texttt{number} is moved to FD \texttt{n} and FD \texttt{number} is then closed
            }
        \item[I/O FDs:] \PB{\small\texttt{[n]<>word}}\\
            {\small
                The file resulting form \texttt{word} is opened for both \PS{reading and writing} on FD \texttt{n}\\[-0.5em]
                \Remark[0pt]{If the file does not exist, it is created}
            }
    \end{description}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{A few more basic examples}
    \begin{overlayarea}{\textwidth}{0.2\textheight}
        \begin{onlyenv}<1>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # Standard process situation
                $ command
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<2>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # Redirect the standard output of a command to a file
                $ command > File
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<3>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # Redirect the standard error of a command to a file
                $ command 2> File
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<4>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # Redirect both std output and std error to a file
                $ command &> File
                # Equivalent to
                $ command > File 2>&1
                # WRONG CODE! Explanation later
                # command > File 2> File 
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<5>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # The order of the redirections matters!
                $ command > File 2>&1
                # command 2>&1 > File
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<6>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # The order of the redirections matters!
                # command > File 2>&1
                $ command 2>&1 > File
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<7>
            \begin{lstlisting}[style=MyBash, numbers=none]
                # Redirect the std input of a command to a file
                $ command < File
            \end{lstlisting}
        \end{onlyenv}
    \end{overlayarea}
    \vfill
    \begin{center}
        \begin{tikzpicture}
            \tikzset{
                fd/.style={minimum size=6mm, draw=#1, thick, font=\ttfamily\small},
                output/.style={minimum height=6mm, minimum width=3cm, draw=#1, thick, font=\small, rounded corners=1mm, text=PB},
                output/.default=PB
            }
            \begin{scope}[visible on=<1>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n in {0,1,2}{
                    \node[output, right = 15mm of fd\n] (output\n) {Terminal};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
            \end{scope}
            \begin{scope}[visible on=<2>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/File,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
            \end{scope}
            \begin{scope}[visible on=<3>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
            \end{scope}
            \begin{scope}[visible on=<4-5>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \draw (fd2) -| ($(fd1.east)!0.5!(output1.west)$);
            \end{scope}
            \begin{scope}[visible on=<6>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal, 2/File}{
                    \node[output, right = 15mm of fd\n] (output\n.west) {\l};
                    
                }
                \draw[to] (fd0.east) -- (output0.west);
                \draw[to] (fd1.east) -- (output2.west);
                \draw[to] (fd2.east) -- (output1.west);
            \end{scope}
            \begin{scope}[visible on=<7>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/File,1/Terminal,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
            \end{scope}
        \end{tikzpicture}
    \end{center}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{The \bash|exec| builtin}
    \vspace{-2mm}
    \begin{varblock}{quote}[0.6\textwidth]{\texttt{exec \ldots [command [arguments]]}}[Bash manual]
        [\ldots] If no command is specified, redirections may be used to affect the current shell environment [\ldots]\smallskip
    \end{varblock}
    \begin{lstlisting}[style=MyBash, numbers=none, belowskip=-4mm]
        # Redirect both std output and std error to "log.txt"
        $ exec > log.txt 2>&1
        # ALL output including stderr now goes into "log.txt"
    \end{lstlisting}
    Otherwise, for local changes, command grouping helps:
    \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm]
        # Redirect both std output and std error to "messages.log"
        {
            date
            # some other commands
            echo '...done!'
        } > messages.log 2>&1
    \end{lstlisting} 
    \FrameRemark{To check the open file descriptors you can use: $\;$ \bash|ls -l /proc/$$/fd|}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{A few more advanced examples}
    \vspace{-5mm}
    \begin{overlayarea}{\textwidth}{0.38\textheight}
        \begin{onlyenv}<1>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Open a file for reading using a custom file descriptor
                $ exec 3< File
                # grep "foo" <&3 # NOTE: You can't rewind a fd in Bash!
                # ...                    Close and open it again in case
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<2>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Open a file for reading using a custom file descriptor
                $ exec 3< File
                # grep "foo" <&3 # NOTE: You can't rewind a fd in Bash!
                # ...                    Close and open it again in case
                $ exec 3<&-
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<3>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Open a file for writing using a custom file descriptor
                $ exec 4> File
                # echo "foo" >&4 
                # ...
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<4>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Open a file for writing using a custom file descriptor
                $ exec 4> File
                # echo "foo" >&4 
                # ...
                $ exec 4>&-
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<5>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                $ echo "foo bar" > File
                # Open a file both for writing and reading with a custom FD
                $ exec 6<> File
                $ read -n 3 var <&6  # read the first 3 characters from FD 6
                $ echo $var 
                $ echo -n + >&6      # write "+" at 4th position
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<6>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                $ echo "foo bar" > File
                # Open a file both for writing and reading with a custom FD
                $ exec 6<> File
                $ read -n 3 var <&6  # read the first 3 characters from FD 6
                $ echo $var 
                $ echo -n + >&6      # write "+" at 4th position
                $ exec 6>&-          # @|\URL[red]{https://unix.stackexchange.com/questions/131801/closing-a-file-descriptor-vs\#comment615492\_131833}{close FD 6}[background-color]|@
                $ cat File
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<7>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Redirect standard output temporarily to file
                $ exec 3>&1 1> File
                $ date
                $ echo "This goes to File without redirection!"
                $ date
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<8>
            \begin{lstlisting}[style=MyBash, numbers=none, xrightmargin=3mm]
                # Redirect standard output temporarily to file
                $ exec 3>&1 1> File
                $ date
                $ echo "This goes to File without redirection!"
                $ date
                $ exec 1>&3 3>&-
                $ echo "I see this in the terminal again!"
                $ cat File
            \end{lstlisting}
        \end{onlyenv}
    \end{overlayarea}
    \begin{center}
        \begin{tikzpicture}
            \tikzset{
                fd/.style={minimum size=6mm, draw=#1, thick, font=\ttfamily\small},
                output/.style={minimum height=6mm, minimum width=3cm, draw=#1, thick, font=\small, rounded corners=1mm, text=PB},
                output/.default=PB
            }
            \begin{scope}[visible on=<1>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \node[fd=PQ, below = 3mm of fd2] (fd3) {3};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal,3/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Open for reading};
            \end{scope}
            \begin{scope}[visible on=<2>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \begin{scope}[opacity=0.2]
                    \node[fd=PQ, below = 3mm of fd2] (fd3) {3};
                    \node[output, right = 15mm of fd3] (output3) {File};
                    \draw[to] (fd3.east) -- (output3.west);
                \end{scope}
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Closed};
            \end{scope}\begin{scope}[visible on=<3>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \node[fd=PQ, below = 3mm of fd2] (fd3) {4};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal,3/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Open for writing};
            \end{scope}
            \begin{scope}[visible on=<4>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \begin{scope}[opacity=0.2]
                    \node[fd=PQ, below = 3mm of fd2] (fd3) {4};
                    \node[output, right = 15mm of fd3] (output3) {File};
                    \draw[to] (fd3.east) -- (output3.west);
                \end{scope}
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Closed};
            \end{scope}
            \begin{scope}[visible on=<5>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \node[fd=PQ, below = 3mm of fd2] (fd3) {6};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal,3/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Open for reading and writing};
            \end{scope}
            \begin{scope}[visible on=<6>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \begin{scope}[opacity=0.2]
                    \node[fd=PQ, below = 3mm of fd2] (fd3) {6};
                    \node[output, right = 15mm of fd3] (output3) {File};
                    \draw[to] (fd3.east) -- (output3.west);
                \end{scope}
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Closed};
            \end{scope}
            \begin{scope}[visible on=<7>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \node[fd=PQ, below = 3mm of fd2] (fd3) {3};
                \foreach \n/\l in {0/Terminal,1/File,2/Terminal,3/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Open for writing};
            \end{scope}
            \begin{scope}[visible on=<8>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 3mm of fd0] (fd1) {1};
                \node[fd=PT, below = 3mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/Terminal,2/Terminal}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \begin{scope}[opacity=0.2]
                    \node[fd=PQ, below = 3mm of fd2] (fd3) {3};
                    \node[output, right = 15mm of fd3] (output3) {Terminal};
                    \draw[to] (fd3.east) -- (output3.west);
                \end{scope}
                \node[anchor=north, text=PB, font=\scriptsize] at (output3.south) {Closed};
            \end{scope}
        \end{tikzpicture}
    \end{center}
    \FrameRemark{File descriptor numbers range from 0 to 255. }
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Redirecting standard output and error to the same place}
    \vspace{-7mm}
    \begin{overlayarea}{\textwidth}{0.5\textheight}
        \begin{varblock}{alerted}[0.9\textwidth]{Why does the naive way fail?}
            \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm]
                $ command > File 2> File   # WRONG CODE!
            \end{lstlisting}
        \end{varblock}
        \only<1>{\vspace{-2mm}}
        \begin{itemize}[<only@1>]
            \item We have created a very bad condition here
            \item Two FDs that both point to the same file, independently of each other, is a \textbf{bad idea}
            \item The results of this are not well-defined
            \item Some information written via one FD may clobber information written through the other FD\\[-0.5em]
                  \Remark{Depending on how the operating system handles FDs}
        \end{itemize}
        \begin{onlyenv}<2>
            \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=0pt]
                $ echo "I am a very proud sentence with a lot of words in it, all for you." > File
                $ grep 'proud' File 'not a file' > proud.log 2> proud.log
                $ cat proud.log
                |+grep: not a file: No such file or directory
                f words in it, all for you.+|
            \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<3>
            \vspace{-2mm}
            \begin{varblock}{example}[0.9\textwidth]{How should I fix this?}
                \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm, xleftmargin=3mm, xrightmargin=3mm]
                    $ command  > File 2>&1   # GOOD CODE!
                    $ command &> File        # ALSO GOOD (Bash specific)
                \end{lstlisting}
            \end{varblock}
        \end{onlyenv}
    \end{overlayarea}
    \medskip
    \begin{center}
        \begin{tikzpicture}
            \tikzset{
                fd/.style={minimum size=6mm, draw=#1, thick, font=\ttfamily\small},
                output/.style={minimum height=6mm, minimum width=3cm, draw=#1, thick, font=\small, rounded corners=1mm, text=PB},
                output/.default=PB
            }
            \begin{scope}[visible on=<1-2>]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \draw[to] (fd2) -| (output1.south);
            \end{scope}
            \begin{scope}[visible on=<3->]
                \node[fd=fg] (fd0) {0};
                \node[fd=PP, below = 5mm of fd0] (fd1) {1};
                \node[fd=PT, below = 5mm of fd1] (fd2) {2};
                \foreach \n/\l in {0/Terminal,1/File}{
                    \node[output, right = 15mm of fd\n] (output\n) {\l};
                    \draw[to] (fd\n.east) -- (output\n.west);
                }
                \draw (fd2) -| ($(fd1.east)!0.5!(output1.west)$);
            \end{scope}
        \end{tikzpicture}
    \end{center}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{A kind of black hole in the operating system}
    \begin{tikzpicture}[overlay, remember picture]
        \node[anchor=north east] (fig) at ($(current page.north east)-(3mm,3mm)$) {\includegraphics[width=3cm]{BlackHole}};
        \node[text=bg, font=\ttfamily] at ($(fig.center)!0.7!(fig.south)$) {/dev/null};
    \end{tikzpicture}
    \vspace{-9mm}
    \begin{columns}[c]
        \begin{column}{0.7\textwidth}
            \begin{varblock}{alerted}[\textwidth]{Do not be too clever!}<uncover@2>
                Suppressing the standard error might not be a so smart idea...
            \end{varblock}
        \end{column}
        \begin{column}{0.3\textwidth}
        \end{column}
    \end{columns}
    \bigskip
    \begin{lstlisting}[style=MyBash, numbers=none]
        $ echo 'Now you see me!'
        |+Now you see me!+|
        $ echo 'Now you do not see me!'  > /dev/null
        $ echo 'Now you do not see me!' >> /dev/null
        $ rm 'Who cares that this does not exists' 2>  /dev/null
        $ rm 'Who cares that this does not exists' 2>> /dev/null
    \end{lstlisting}
    \bigskip
    \begin{itemize}
        \item The file \texttt{/dev/null} is always empty, no matter what you write to it or read from it
        \item As such, when we write our (error) messages to it, they just disappear
        \item The \texttt{/dev/null} file remains as empty as ever before
        \item That's because it is not a normal file: It is a virtual device
        \item \PP{Redirecting \texttt{/dev/null} to \textbf{standard input} will give an immediate EOF to any read call}
    \end{itemize}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Here Documents (I)}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash, numbers=none]
        command |+[n]<<[-]WORD+|
            # here document
        |+WORD+|
    \end{lstlisting}
    \vspace{2mm}
    \begin{itemize}
        \item Heredocs are useful to embed \textbf{short} blocks of multi-line data inside your script\\[-0.5ex]
              \Remark[0pt]{Embedding larger blocks is bad practice!}
        \item In a Heredoc, you need to choose a \texttt{WORD} to act as a sentinel
        \item It can be any word: Choose one that won't appear in your data set
        \item All the lines that follow the first instance of the sentinel, up to the second instance, become the standard input for the \bash|command| 
        \item The second instance of the sentinel word has to be \alert{at the beginning of a line all by itself}
    \end{itemize}
    \begin{varblock}{quote}[0.7\textwidth]{Good practice}
        \textnormal{You should keep \PP{your logic} \Remark[0pt]{your code} and \PP{your input} \Remark[0pt]{your data} \PP{separated}, preferably in different files, unless it is a small data set!}
    \end{varblock}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Here Documents (II)}
    \vspace{-5mm}
    \begin{enumerate}
        \item Standard form
              \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm]
                  command |+<<WORD+|
                      # here document subjected to parameter expansion,
                      # command substitution, and arithmetic expansion
                  |+WORD+|
              \end{lstlisting}
        \item Quoting (part of) the sentinel word
              \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm]
                  command <<'WORD'
                      # the lines in the here-document are not expanded
                  |+WORD+|
              \end{lstlisting}
        \item Adding a dash before the sentinel word to indent code
              \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=2mm, belowskip=-5mm]
                  command |+<<-WORD+|
                      # Leading tabs (NOT spaces!) are removed
                  |+WORD+|
              \end{lstlisting}
        \item Combining the previous two forms is clearly allowed
    \end{enumerate}
    \FrameRemark{No parameter and variable expansion, command substitution, arithmetic expansion, or filename expansion is performed on \texttt{WORD}.}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Here Documents (III): Examples}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash]
        # Standard form
        $ if [[ $(date +'%A') |+!=+| S* ]]; then
        >     cat <<END
        >         Ouch, it is not weekend: $(date +'%A')
        > END
        > fi
        |+       Ouch, it is not weekend: Wednesday+|
        # Removing leading tabs
        $ cat <<-END
        >     abc seems to start with an a! # TAB before 'abc'
        > END                               # (CTRL-v TAB)
        |+abc seems to start with an a!+|
        # Avoiding expansion
        $ cat <<-'SENTINEL'
        >     My home is ${HOME}            # TAB before 'My'
        > SENTINEL
        |+My home is ${HOME}+|
    \end{lstlisting}
    \begin{uncoverenv}<2>
        \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=4pt]
            cat |+<<EOF
            usage: foobar [-x] [-v] [-z] [file ...]
              A short explanation of the operation goes here.
              It might be few lines long, but should not be excessive.
            EOF+|
        \end{lstlisting}
    \end{uncoverenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Here Strings}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash, numbers=none]
        command |+[n]<<< STRING+|
    \end{lstlisting}
    \vspace{2mm}
    \begin{itemize}[<only@1-2>]
        \item Herestrings are shorter, less intrusive and overall more convenient than Heredocs\\[-0.5ex]
              \Remark[0pt]{However, they are not portable to the Bourne shell}
        \item The \texttt{STRING} undergoes:
              \begin{itemize}
                  \item tilde expansion
                  \item parameter and variable expansion
                  \item command substitution
                  \item arithmetic expansion
                  \item quote removal\tikzmark{quotes}
              \end{itemize}
        \item \alert{Pathname expansion} and word splitting \alert{are \textbf{not} performed}
        \item The result is supplied as a \alert{\textbf{single}} string, with a newline appended, to the \bash{command} on its standard input (or file descriptor \texttt{n} if specified)
    \end{itemize}
    \begin{varblock}{quote}[0.5\textwidth]{Good practice}<only@1-2>
        \textnormal{Prefer Herestrings to pipes whenever possible!}
    \end{varblock}
    \begin{onlyenv}<3>
        \begin{lstlisting}[style=MyBash, style=oddnumbers]
            $ grep |+--color=auto+| '[aeiou]' <<< "Clark Kent"
            @|Cl\tc{red}{a}rk K\tc{red}{e}nt|@
            $ bc <<< "10/4"
            |+2+|
            $ bc -l <<< "10/4"
            |+2.50000000000000000000+|
            $ bc <<< "obase=16; ibase=2; 11000000"
            |+B64+|
            $ bc <<< "ibase=2; obase=10000; 11000000"
            |+C0+|
            $ wc -w <<< "Day of the week as number: $(date +'%w')"
            |+7+|
            $ ls
            |+Day_1.pdf   Day_2.pdf+|
            $ echo *
            |+Day_1.pdf Day_2.pdf+|
            $ wc -c <<< *           # No filename expansion!
            |+2+|                       # Why 2 characters?
        \end{lstlisting}
    \end{onlyenv}
    \begin{tikzpicture}[remember picture, overlay, scope on=<2>]
        \path[from] (quotes) edge[out=0, in=270, looseness=0.5] node[pos=1, above, text=PT, draw=PQ, rounded corners=3mm, text width=30mm, align=center, font=\small] {Do not forget quotes, especially if the string contains spaces!} ++(5.2,1);
    \end{tikzpicture}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\againframe<3,5>{FDfigure}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Pipes}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash, numbers=none]
        command | command
    \end{lstlisting}
    \vspace{2mm}
    \begin{itemize}
        \item The pipe is created using the \PB{\texttt{|}} operator between two commands
        \item The former \bash{command}'s std output is connected to the latter \bash{command}'s std input
        \item This connection is performed before any redirection specified by the commands
        \item Pipes are widely used as a means of post-processing application output
        \item \alert{The pipe operator creates a subshell environment for each command!} \Remark{More on subshells later}
    \end{itemize}
    \begin{onlyenv}<1>
        \begin{lstlisting}[style=MyBash, aboveskip=3mm]
            $ message='Test'
            $ echo 'Salut, le monde!' | read message
            $ echo "The message is: ${message}"
            |+The message is: Test+|
            $ echo 'Salut, le monde!' | { read message;
            > echo "The message is: ${message}"; }
            |+The message is: Salut, le monde!+|
            $ echo "The message is: ${message}"
            |+The message is: Test+|
        \end{lstlisting}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \begin{lstlisting}[style=MyBash, numbers=none, aboveskip=3mm]
            command 2>&1 |  command
            command      |& command
        \end{lstlisting}
        \vspace{2mm}
        \begin{itemize}
            \item \PB{\texttt{|\&}} also connects the first \bash{command}'s std error to the second \bash{command}'s std input
            \item It is shorthand for \PB{\texttt{2>\&1 |}}
            \item This implicit redirection is performed after any redirection specified by the commands
        \end{itemize}
    \end{onlyenv}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Pipes: A simple example}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash]
        # Finding the maximum of a list
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done
        |+1.4122
        2.15901
        0.19098
        0.6631
        0.15050+|
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done | sort -n
        |+0.1455
        0.32373
        0.9598
        1.18896
        1.2768+|
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done | sort -n | tail -n1
        |+2.21350+|
    \end{lstlisting}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Pipes: Exit codes}
    \vspace{-3mm}
    \begin{itemize}
        \item The exit status of a pipeline is the exit status of the last command in the pipeline
        \item Bash provides an array variable \bash|PIPESTATUS| containing a list of exit status values from the processes in the most-recently-executed foreground process
    \end{itemize}
    \begin{lstlisting}[style=MyBash, aboveskip=3mm]
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done | sort -n | tail -n1 | grep 'x'
        $ echo $?
        1
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done | sort -n | tail -n1 | grep 'x'
        $ echo ${PIPESTATUS[@]}
        |+0 0 0 1+|
        $ for index in {1..5}; do
        >     echo $((RANDOM/RANDOM)).${RANDOM}
        > done | sort -n | rm 2> /dev/null | tail -n1 | grep 'x'
        $ echo ${PIPESTATUS[@]}
        |+0 141 1 0 1+| # @|\URL[red]{https://stackoverflow.com/a/19120674}{Pipes must have a reader (rm is not) and a writer}[background-color]|@
    \end{lstlisting}
    \FrameRemark{If \texttt{pipefail} is enabled, the pipeline's return status is the value of the rightmost command to exit with a non-zero status, or zero if all commands exit successfully.}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
\begin{frame}[fragile]{Process substitution}
    \vspace{-3mm}
    \begin{lstlisting}[style=MyBash, numbers=none]
        command <(list)   # No space between < and (
        command >(list)   # No space between > and (
    \end{lstlisting}
    \vspace{3mm}
    \begin{onlyenv}<1>
        \begin{enumerate}\small
            \item The process list is run asynchronously, and its input or output appears as a filename
            \item This filename is passed as an argument to the current command as the result of the expansion\\[0.3em]
                  \begin{description}[\texttt{>(list)}]
                      \setlength{\itemsep}{2mm}
                      \item[\texttt{>(command\_list)}] ~\\[0.3em]
                          \hspace{-1cm}writing to the file will provide input for \PB{\texttt{command\_list}} \Remark{Rarely needed!}
                      \item[\texttt{<(command\_list)}] ~\\[0.3em]
                          \hspace{-1cm}the file passed as an argument should be read to obtain the output of \PB{\texttt{command\_list}}
                  \end{description}
        \end{enumerate}
        \begin{varblock}{}[0.82\textwidth]{The power of process substitution}
            Piping the stdout of a command into the stdin of another is a powerful technique.
            But, what if you need to pipe the stdout of multiple commands?\\
            \textbf{This is where process substitution comes in!}
        \end{varblock}
    \end{onlyenv}
    \begin{onlyenv}<2>
        \begin{lstlisting}[style=MyBash, xleftmargin=2mm, xrightmargin=0mm]
            $ cat <(date)   # Equivalent to a pipeline
            |+Wed 24 Jul 16:37:23 CEST 2019+|
            $ echo <(date)
            |+/dev/fd/63+|
            # Here a pipeline is not enough!
            $ cat <(date +'%T-%N') <(date +'%T-%N') <(date +'%T-%N')
            |+16:43:16-957108564+|
            |+16:43:16-958083851+|  # <(...) <(...) <(...) happen 'concurrently'@|$^\star$|@
            |+16:43:16-957603584+|
            $ echo <(date +'%T-%N') <(date +'%T-%N') <(date +'%T-%N')
            |+/dev/fd/63 /dev/fd/62 /dev/fd/61+|
            $ cat < <(date)
            |+Wed 24 Jul 16:53:43 CEST 2019+|
            $ echo < <(date)
            # Why do you get a blank output here?
            $ sdiff -s <(head Day_1.tex) <(head Day_2.tex)
            |+\subtitle{Day 1}                        | \subtitle{Day 2}
            \date{26.10.2019}                       | \date{27.10.2019}+|
        \end{lstlisting}
    \end{onlyenv}
    \FrameRemark[2]{$^\star$This is an incomplete statement, if taken as general rule: It is not \URL[PB]{https://unix.stackexchange.com/questions/403783/the-process-substitution-output-is-out-of-the-order}{the full story}.}
\end{frame}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
